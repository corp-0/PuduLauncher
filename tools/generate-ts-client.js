import { readFileSync, writeFileSync, mkdirSync, readdirSync, statSync } from "fs";
import { join, basename } from "path";

const DOTNET_SRC = "src-dotnet";
const OUTPUT_DIR = "src/pudu/generated";
const HEADER = "// This file is auto-generated by tools/generate-ts-client.js — DO NOT EDIT\n";

// C# to TypeScript type mapping
const TYPE_MAP = {
  string: "string",
  int: "number",
  long: "number",
  float: "number",
  double: "number",
  decimal: "number",
  bool: "boolean",
  boolean: "boolean",
  DateTime: "string",
  DateTimeOffset: "string",
  Guid: "string",
  object: "unknown",
  void: "void",
};

// Convert PascalCase to camelCase
function toCamelCase(name) {
  return name.charAt(0).toLowerCase() + name.slice(1);
}

// Convert PascalCase to kebab-case
function toKebabCase(name) {
  return name.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}

// Map a C# type string to TypeScript
function mapType(csType) {
  if (!csType) return "unknown";
  csType = csType.trim();

  // Nullable types: string? -> string | undefined
  if (csType.endsWith("?")) {
    const inner = csType.slice(0, -1);
    return `${mapType(inner)} | undefined`;
  }

  // Array types: string[] -> string[]
  if (csType.endsWith("[]")) {
    const inner = csType.slice(0, -2);
    return `${mapType(inner)}[]`;
  }

  // Generic collection types
  const genericMatch = csType.match(/^(List|IList|IEnumerable|ICollection|IReadOnlyList)<(.+)>$/);
  if (genericMatch) {
    return `${mapType(genericMatch[2])}[]`;
  }

  const dictMatch = csType.match(/^(Dictionary|IDictionary|IReadOnlyDictionary)<string,\s*(.+)>$/);
  if (dictMatch) {
    return `Record<string, ${mapType(dictMatch[2])}>`;
  }

  // Task<T> -> unwrap to T
  const taskMatch = csType.match(/^Task<(.+)>$/);
  if (taskMatch) {
    return mapType(taskMatch[1]);
  }

  // CommandResult<T> -> keep as generic
  const cmdResultMatch = csType.match(/^CommandResult<(.+)>$/);
  if (cmdResultMatch) {
    return `CommandResult<${mapType(cmdResultMatch[1])}>`;
  }

  // Direct mapping
  if (TYPE_MAP[csType]) return TYPE_MAP[csType];

  // Unknown type — assume it will be generated as an interface
  return csType;
}

// Recursively find all .cs files in a directory
function findCsFiles(dir) {
  const results = [];
  try {
    for (const entry of readdirSync(dir)) {
      const full = join(dir, entry);
      try {
        const stat = statSync(full);
        if (stat.isDirectory()) {
          results.push(...findCsFiles(full));
        } else if (entry.endsWith(".cs")) {
          results.push(full);
        }
      } catch {
        // skip inaccessible
      }
    }
  } catch {
    // skip inaccessible
  }
  return results;
}

// Parse controllers from C# source files
function parseControllers() {
  const controllerFiles = findCsFiles(DOTNET_SRC).filter((f) =>
    f.replace(/\\/g, "/").includes("/Controllers/")
  );

  const controllers = [];

  for (const file of controllerFiles) {
    const content = readFileSync(file, "utf-8");

    // Match [PuduController("name")]
    const controllerMatch = content.match(
      /\[PuduController\("([^"]+)"\)\]\s*(?:public\s+)?(?:sealed\s+)?class\s+(\w+)/
    );
    if (!controllerMatch) continue;

    const controllerName = controllerMatch[1];
    const className = controllerMatch[2];
    const commands = [];

    // Match [PuduCommand("name")] followed by method signature
    const commandRegex =
      /\[PuduCommand\("([^"]+)"\)\]\s*public\s+(?:async\s+)?([\w<>,\s]+?)\s+(\w+)\(([^)]*)\)/g;
    let match;
    while ((match = commandRegex.exec(content)) !== null) {
      const commandName = match[1];
      const returnType = match[2].trim();
      const methodName = match[3];
      const params = match[4].trim();

      // Parse parameter
      let paramType = null;
      let paramName = null;
      if (params) {
        const paramMatch = params.match(/^(\w[\w<>,\s]*?)\s+(\w+)$/);
        if (paramMatch) {
          paramType = paramMatch[1].trim();
          paramName = paramMatch[2];
        }
      }

      commands.push({
        commandName,
        methodName,
        returnType,
        paramType,
        paramName,
      });
    }

    // Also match [PuduCommand] without explicit name (kebab-case method name)
    const commandNoNameRegex =
      /\[PuduCommand\]\s*public\s+(?:async\s+)?([\w<>,\s]+?)\s+(\w+)\(([^)]*)\)/g;
    while ((match = commandNoNameRegex.exec(content)) !== null) {
      const returnType = match[1].trim();
      const methodName = match[2];
      const params = match[3].trim();
      const commandName = toKebabCase(methodName);

      let paramType = null;
      let paramName = null;
      if (params) {
        const paramMatch = params.match(/^(\w[\w<>,\s]*?)\s+(\w+)$/);
        if (paramMatch) {
          paramType = paramMatch[1].trim();
          paramName = paramMatch[2];
        }
      }

      commands.push({
        commandName,
        methodName,
        returnType,
        paramType,
        paramName,
      });
    }

    if (commands.length > 0) {
      controllers.push({ controllerName, className, commands });
    }
  }

  return controllers;
}

// Parse model types (records and classes)
function parseModels() {
  const modelFiles = findCsFiles(DOTNET_SRC).filter((f) => {
    const normalized = f.replace(/\\/g, "/");
    return (
      normalized.includes("/Models/") ||
      normalized.includes("/Abstractions/Models/")
    );
  });

  const models = new Map();

  for (const file of modelFiles) {
    const content = readFileSync(file, "utf-8");

    // Match records: public record Foo(Type Prop, Type Prop);
    const recordRegex =
      /public\s+(?:sealed\s+)?record\s+(\w+)\s*\(([^)]+)\)\s*;/g;
    let match;
    while ((match = recordRegex.exec(content)) !== null) {
      const name = match[1];
      const paramsStr = match[2];
      const properties = [];

      for (const param of paramsStr.split(",")) {
        const trimmed = param.trim();
        const parts = trimmed.match(/^([\w<>?[\],\s]+?)\s+(\w+)$/);
        if (parts) {
          properties.push({
            name: toCamelCase(parts[2]),
            type: mapType(parts[1].trim()),
            optional: parts[1].trim().endsWith("?"),
          });
        }
      }

      models.set(name, { name, properties, extends: null });
    }

    // Match classes with properties (including events)
    const classRegex =
      /public\s+(?:sealed\s+)?(?:abstract\s+)?class\s+(\w+)(?:<(\w+)>)?(?:\s*:\s*(\w+))?\s*\{/g;
    while ((match = classRegex.exec(content)) !== null) {
      const name = match[1];
      const genericParam = match[2] || null;
      const baseClass = match[3] || null;

      // Skip if it's a generic class definition (like CommandResult<T>)
      if (genericParam) continue;

      // Find properties
      const properties = [];
      const propRegex =
        /public\s+([\w<>?[\],\s]+?)\s+(\w+)\s*\{\s*get;\s*(?:init|set);\s*\}/g;
      let propMatch;
      const classBody = content.slice(match.index);
      while ((propMatch = propRegex.exec(classBody)) !== null) {
        // Stop if we hit another class
        if (propMatch.index > classBody.indexOf("\n}")) break;

        const propType = propMatch[1].trim();
        const propName = propMatch[2];

        properties.push({
          name: toCamelCase(propName),
          type: mapType(propType),
          optional: propType.endsWith("?"),
        });
      }

      if (properties.length > 0 || baseClass) {
        models.set(name, { name, properties, extends: baseClass });
      }
    }
  }

  return models;
}

// Generate types.ts
function generateTypes(models) {
  let output = HEADER + "\n";

  // Always include CommandResult<T> and EventBase as hardcoded types
  output += `export interface CommandResult<T> {\n`;
  output += `  success: boolean;\n`;
  output += `  data?: T;\n`;
  output += `  error?: string;\n`;
  output += `}\n\n`;

  output += `export interface EventBase {\n`;
  output += `  eventType: string;\n`;
  output += `  timestamp: string;\n`;
  output += `}\n\n`;

  // Generate interfaces for each model
  for (const [name, model] of models) {
    // Skip base types we already hardcoded
    if (name === "CommandResult" || name === "EventBase") continue;

    const extendsClause = model.extends ? ` extends ${model.extends}` : "";
    output += `export interface ${name}${extendsClause} {\n`;
    for (const prop of model.properties) {
      const optionalMark = prop.optional ? "?" : "";
      output += `  ${prop.name}${optionalMark}: ${prop.type};\n`;
    }
    output += `}\n\n`;
  }

  return output.trimEnd() + "\n";
}

// Generate API client file for a controller
function generateApiClient(controller, models) {
  const { controllerName, commands } = controller;

  // Collect import types
  const importTypes = new Set();
  for (const cmd of commands) {
    if (cmd.paramType) importTypes.add(cmd.paramType);
    // Always import CommandResult for return types
    importTypes.add("CommandResult");
  }

  let output = HEADER + "\n";
  const importList = [...importTypes].sort().join(", ");
  output += `import type { ${importList} } from './types';\n`;
  output += `import { getSidecarBaseUrl } from '../sidecar';\n\n`;

  // Class name: "greeter" -> "GreeterApi"
  const apiClassName =
    controllerName.charAt(0).toUpperCase() + controllerName.slice(1) + "Api";

  output += `export class ${apiClassName} {\n`;

  for (const cmd of commands) {
    const tsMethodName = toCamelCase(cmd.methodName);
    const tsReturnType = mapType(cmd.returnType);

    if (cmd.paramType) {
      const tsParamType = mapType(cmd.paramType);
      output += `  async ${tsMethodName}(command: ${tsParamType}): Promise<${tsReturnType}> {\n`;
      output += `    const baseUrl = await getSidecarBaseUrl();\n`;
      output += `    const response = await fetch(\`\${baseUrl}/api/${controllerName}/${cmd.commandName}\`, {\n`;
      output += `      method: 'POST',\n`;
      output += `      headers: { 'Content-Type': 'application/json' },\n`;
      output += `      body: JSON.stringify(command),\n`;
      output += `    });\n`;
    } else {
      output += `  async ${tsMethodName}(): Promise<${tsReturnType}> {\n`;
      output += `    const baseUrl = await getSidecarBaseUrl();\n`;
      output += `    const response = await fetch(\`\${baseUrl}/api/${controllerName}/${cmd.commandName}\`, {\n`;
      output += `      method: 'POST',\n`;
      output += `    });\n`;
    }

    output += `    if (!response.ok) throw new Error(\`HTTP error! status: \${response.status}\`);\n`;
    output += `    return response.json();\n`;
    output += `  }\n\n`;
  }

  output = output.trimEnd() + "\n}\n";
  return { fileName: `${toKebabCase(controllerName)}-api.ts`, content: output, apiClassName };
}

// Generate index.ts barrel export
function generateIndex(controllers, models) {
  let output = HEADER + "\n";
  output += `export * from './types';\n`;
  for (const { fileName, apiClassName } of controllers) {
    const moduleName = "./" + fileName.replace(".ts", "");
    output += `export { ${apiClassName} } from '${moduleName}';\n`;
  }
  return output;
}

// Main
function main() {
  console.log("[generate-ts] Scanning C# source files...");

  const controllers = parseControllers();
  const models = parseModels();

  console.log(
    `[generate-ts] Found ${controllers.length} controller(s), ${models.size} model(s)`
  );

  if (controllers.length === 0) {
    console.log("[generate-ts] No controllers found, skipping generation.");
    return;
  }

  // Create output directory
  mkdirSync(OUTPUT_DIR, { recursive: true });

  // Generate types.ts
  const typesContent = generateTypes(models);
  writeFileSync(join(OUTPUT_DIR, "types.ts"), typesContent);
  console.log("[generate-ts] Generated types.ts");

  // Generate per-controller API clients
  const apiFiles = [];
  for (const controller of controllers) {
    const { fileName, content, apiClassName } = generateApiClient(
      controller,
      models
    );
    writeFileSync(join(OUTPUT_DIR, fileName), content);
    apiFiles.push({ fileName, apiClassName });
    console.log(`[generate-ts] Generated ${fileName}`);
  }

  // Generate index.ts
  const indexContent = generateIndex(apiFiles, models);
  writeFileSync(join(OUTPUT_DIR, "index.ts"), indexContent);
  console.log("[generate-ts] Generated index.ts");

  console.log(`[generate-ts] Done! Output: ${OUTPUT_DIR}/`);
}

main();
