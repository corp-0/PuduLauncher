import { execSync } from "child_process";
import {
  mkdirSync,
  readdirSync,
  readFileSync,
  rmSync,
  statSync,
  writeFileSync,
} from "fs";
import { dirname, join } from "path";

const DOTNET_PROJECT = "src-dotnet/PuduLauncher/PuduLauncher.csproj";
const MANIFEST_COMPILER_GENERATED_DIR = "obj/ts-manifest/generated";
const MANIFEST_BUILD_OUTPUT = "obj/ts-manifest/build-out/";
const GENERATED_OBJ_DIR = "src-dotnet/PuduLauncher/obj/ts-manifest/generated";
const OUTPUT_DIR = "src/pudu/generated";
const JSON_CONTEXT_OUTPUT =
  "src-dotnet/PuduLauncher/Host/Serialization/JsonCtx.Models.g.cs";
const MANIFEST_FILE = "PuduContractManifest.g.cs";
const MANIFEST_START = "PUDU_MANIFEST_START";
const MANIFEST_END = "PUDU_MANIFEST_END";
const HEADER = "// This file is auto-generated by tools/generate-ts-client.js - DO NOT EDIT\n";

function toCamelCase(name) {
  return name.charAt(0).toLowerCase() + name.slice(1);
}

function toKebabCase(name) {
  return name.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}

function escapeTsStringLiteral(value) {
  return value.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
}

function findFilesByName(dir, fileName) {
  const matches = [];
  if (!statExists(dir)) return matches;

  for (const entry of readdirSync(dir)) {
    const full = join(dir, entry);
    const stat = statSync(full);
    if (stat.isDirectory()) {
      matches.push(...findFilesByName(full, fileName));
      continue;
    }
    if (entry === fileName) {
      matches.push(full);
    }
  }
  return matches;
}

function statExists(path) {
  try {
    statSync(path);
    return true;
  } catch {
    return false;
  }
}

function buildAndLoadManifest() {
  console.log("[generate-ts] Building .NET project to produce manifest...");
  execSync(
    `dotnet build ${DOTNET_PROJECT} -c Debug -nologo /p:EmitCompilerGeneratedFiles=true /p:CompilerGeneratedFilesOutputPath=${MANIFEST_COMPILER_GENERATED_DIR} /p:OutputPath=${MANIFEST_BUILD_OUTPUT}`,
    { stdio: "inherit" }
  );

  const manifestCandidates = findFilesByName(GENERATED_OBJ_DIR, MANIFEST_FILE).sort((a, b) => {
    const aTime = statSync(a).mtimeMs;
    const bTime = statSync(b).mtimeMs;
    return bTime - aTime;
  });

  if (manifestCandidates.length === 0) {
    throw new Error(
      `[generate-ts] Could not find ${MANIFEST_FILE} under ${GENERATED_OBJ_DIR}.`
    );
  }

  for (const file of manifestCandidates) {
    const content = readFileSync(file, "utf-8");
    const regex = new RegExp(
      `/\\*${MANIFEST_START}\\s*([\\s\\S]*?)\\s*${MANIFEST_END}\\*/`,
      "m"
    );
    const match = content.match(regex);
    if (!match) continue;

    try {
      const manifest = JSON.parse(match[1]);
      return { manifest, file };
    } catch {
      // Try the next candidate
    }
  }

  throw new Error(
    `[generate-ts] Could not parse manifest JSON from ${MANIFEST_FILE}.`
  );
}

function clearGeneratedFiles() {
  mkdirSync(OUTPUT_DIR, { recursive: true });

  for (const entry of readdirSync(OUTPUT_DIR)) {
    if (!entry.endsWith(".ts")) continue;
    rmSync(join(OUTPUT_DIR, entry));
  }
}

function generateTypes(manifest) {
  let output = HEADER + "\n";

  const models = [...(manifest.models ?? [])].sort((a, b) => a.name.localeCompare(b.name));
  const eventModels = models
    .filter(
      (model) =>
        typeof model.eventType === "string" &&
        model.eventType.length > 0 &&
        (model.typeParameters ?? []).length === 0
    )
    .sort((a, b) => {
      const eventTypeCompare = a.eventType.localeCompare(b.eventType);
      if (eventTypeCompare !== 0) {
        return eventTypeCompare;
      }

      return a.name.localeCompare(b.name);
    });

  for (const model of models) {
    const typeParams = model.typeParameters ?? [];
    const typeParamClause = typeParams.length > 0 ? `<${typeParams.join(", ")}>` : "";
    const extendsClause = model.baseType ? ` extends ${model.baseType}` : "";
    output += `export interface ${model.name}${typeParamClause}${extendsClause} {\n`;
    const modelEventType = typeof model.eventType === "string" ? model.eventType : null;
    const hasEventTypeProperty = (model.properties ?? []).some((prop) => prop.name === "eventType");
    if (modelEventType && !hasEventTypeProperty) {
      output += `  eventType: '${escapeTsStringLiteral(modelEventType)}';\n`;
    }
    for (const prop of model.properties ?? []) {
      const optionalMark = prop.optional ? "?" : "";
      const propType =
        modelEventType && prop.name === "eventType"
          ? `'${escapeTsStringLiteral(modelEventType)}'`
          : prop.type;
      output += `  ${prop.name}${optionalMark}: ${propType};\n`;
    }
    output += "}\n\n";
  }

  output += "export interface PuduEventMap {\n";
  for (const eventModel of eventModels) {
    output += `  '${escapeTsStringLiteral(eventModel.eventType)}': ${eventModel.name};\n`;
  }
  output += "}\n\n";
  output += "export type PuduEventType = keyof PuduEventMap;\n";
  output += "export type PuduEvent = PuduEventMap[PuduEventType];\n\n";

  return output.trimEnd() + "\n";
}

function isOpenGenericClrType(typeText, modelByName) {
  const genericMatch = typeText.match(/^(?:global::)?[\w.]+<(.+)>$/);
  if (!genericMatch) return false;

  const args = genericMatch[1]
    .split(",")
    .map((part) => part.trim())
    .map((part) => part.replace(/^global::/, ""));

  for (const arg of args) {
    if (modelByName.has(arg)) continue;
    if (/^[A-Z][A-Za-z0-9_]*$/.test(arg)) return true;
  }

  return false;
}

function normalizeClrTypeForTypeOf(typeText) {
  return typeText.replace(/\?/g, "");
}

function generateJsonSerializerContext(manifest) {
  const modelByName = new Set((manifest.models ?? []).map((m) => m.name));
  const clrTypes = new Set(["global::System.String"]);

  for (const model of manifest.models ?? []) {
    if (!model.clrType) continue;
    if ((model.typeParameters ?? []).length > 0) continue;
    clrTypes.add(normalizeClrTypeForTypeOf(model.clrType));
  }

  for (const controller of manifest.controllers ?? []) {
    for (const cmd of controller.commands ?? []) {
      for (const param of cmd.parameters ?? []) {
        if (param.clrType) {
          clrTypes.add(normalizeClrTypeForTypeOf(param.clrType));
        }
      }
      if (cmd.returnClrType) {
        const normalized = normalizeClrTypeForTypeOf(cmd.returnClrType);
        if (!isOpenGenericClrType(normalized, modelByName)) {
          clrTypes.add(normalized);
        }
      }
    }
  }

  const sortedTypes = [...clrTypes].sort();

  let output = HEADER + "\n";
  output += "using System.Text.Json.Serialization;\n\n";
  output += "namespace PuduLauncher;\n\n";
  output += "[JsonSourceGenerationOptions(\n";
  output += "    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,\n";
  output += "    PropertyNameCaseInsensitive = true,\n";
  output += "    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,\n";
  output += "    WriteIndented = false)]\n";

  for (const clrType of sortedTypes) {
    output += `[JsonSerializable(typeof(${clrType}))]\n`;
  }

  output += "public partial class JsonCtx\n";
  output += "{\n";
  output += "}\n";

  return output;
}

function extractTypeNames(type, knownTypeNames) {
  if (!type) return [];
  const matches = type.match(/\b[A-Za-z_][A-Za-z0-9_]*\b/g) ?? [];
  const refs = new Set();
  for (const token of matches) {
    if (knownTypeNames.has(token)) refs.add(token);
  }
  return [...refs];
}

function generateApiClient(controller, knownTypeNames) {
  const importTypes = new Set();
  const commands = [...(controller.commands ?? [])].sort((a, b) =>
    a.name.localeCompare(b.name)
  );

  for (const cmd of commands) {
    for (const param of cmd.parameters ?? []) {
      for (const typeName of extractTypeNames(param.type, knownTypeNames)) {
        importTypes.add(typeName);
      }
    }
    for (const typeName of extractTypeNames(cmd.returnType, knownTypeNames)) {
      importTypes.add(typeName);
    }
  }

  let output = HEADER + "\n";
  if (importTypes.size > 0) {
    const importList = [...importTypes].sort().join(", ");
    output += `import type { ${importList} } from './types';\n`;
  }
  output += "import { getSidecarBaseUrl } from '../sidecar';\n\n";

  const apiClassName =
    controller.name.charAt(0).toUpperCase() + controller.name.slice(1) + "Api";

  output += `export class ${apiClassName} {\n`;
  for (const cmd of commands) {
    const tsMethodName = toCamelCase(cmd.methodName);
    const tsReturnType = cmd.returnType || "unknown";

    const params = cmd.parameters ?? [];

    if (params.length === 0) {
      output += `  async ${tsMethodName}(): Promise<${tsReturnType}> {\n`;
      output += "    const baseUrl = await getSidecarBaseUrl();\n";
      output += `    const response = await fetch(\`\${baseUrl}/api/${controller.name}/${cmd.name}\`, {\n`;
      output += "      method: 'POST',\n";
      output += "    });\n";
    } else if (params.length === 1) {
      output += `  async ${tsMethodName}(${params[0].name}: ${params[0].type}): Promise<${tsReturnType}> {\n`;
      output += "    const baseUrl = await getSidecarBaseUrl();\n";
      output += `    const response = await fetch(\`\${baseUrl}/api/${controller.name}/${cmd.name}\`, {\n`;
      output += "      method: 'POST',\n";
      output += "      headers: { 'Content-Type': 'application/json' },\n";
      output += `      body: JSON.stringify(${params[0].name}),\n`;
      output += "    });\n";
    } else {
      const paramSig = params.map(p => `${p.name}: ${p.type}`).join("; ");
      output += `  async ${tsMethodName}(params: { ${paramSig} }): Promise<${tsReturnType}> {\n`;
      output += "    const baseUrl = await getSidecarBaseUrl();\n";
      output += `    const response = await fetch(\`\${baseUrl}/api/${controller.name}/${cmd.name}\`, {\n`;
      output += "      method: 'POST',\n";
      output += "      headers: { 'Content-Type': 'application/json' },\n";
      output += "      body: JSON.stringify(params),\n";
      output += "    });\n";
    }

    output +=
      "    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n";
    if (cmd.isVoid) {
      output += "    return;\n";
    } else {
      output += "    return response.json();\n";
    }
    output += "  }\n\n";
  }

  output = output.trimEnd() + "\n}\n";
  return {
    fileName: `${toKebabCase(controller.name)}-api.ts`,
    content: output,
    apiClassName,
  };
}

function generateIndex(apiFiles) {
  let output = HEADER + "\n";
  output += "export * from './types';\n";
  for (const { fileName, apiClassName } of apiFiles) {
    const moduleName = "./" + fileName.replace(".ts", "");
    output += `export { ${apiClassName} } from '${moduleName}';\n`;
  }
  return output;
}

function main() {
  const { manifest, file } = buildAndLoadManifest();
  const controllers = [...(manifest.controllers ?? [])].sort((a, b) =>
    a.name.localeCompare(b.name)
  );

  console.log(
    `[generate-ts] Loaded manifest v${manifest.version} from ${file} (${controllers.length} controller(s), ${(manifest.models ?? []).length} model(s))`
  );

  clearGeneratedFiles();

  const typesContent = generateTypes(manifest);
  writeFileSync(join(OUTPUT_DIR, "types.ts"), typesContent);
  console.log("[generate-ts] Generated types.ts");

  const jsonContextContent = generateJsonSerializerContext(manifest);
  mkdirSync(dirname(JSON_CONTEXT_OUTPUT), { recursive: true });
  writeFileSync(JSON_CONTEXT_OUTPUT, jsonContextContent);
  console.log("[generate-ts] Generated JsonCtx.Models.g.cs");

  const knownTypeNames = new Set([
    ...((manifest.models ?? []).map((m) => m.name)),
  ]);

  const apiFiles = [];
  for (const controller of controllers) {
    const { fileName, content, apiClassName } = generateApiClient(
      controller,
      knownTypeNames
    );
    writeFileSync(join(OUTPUT_DIR, fileName), content);
    apiFiles.push({ fileName, apiClassName });
    console.log(`[generate-ts] Generated ${fileName}`);
  }

  const indexContent = generateIndex(apiFiles);
  writeFileSync(join(OUTPUT_DIR, "index.ts"), indexContent);
  console.log("[generate-ts] Generated index.ts");

  console.log(`[generate-ts] Done! Output: ${OUTPUT_DIR}/`);
}

main();
