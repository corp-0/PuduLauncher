import { execSync } from "child_process";
import {
  mkdirSync,
  readdirSync,
  readFileSync,
  rmSync,
  statSync,
  writeFileSync,
} from "fs";
import { dirname, join } from "path";

const DOTNET_PROJECT = "src-dotnet/PuduLauncher/PuduLauncher.csproj";
const MANIFEST_COMPILER_GENERATED_DIR = "obj/ts-manifest/generated";
const MANIFEST_BUILD_OUTPUT = "obj/ts-manifest/build-out/";
const GENERATED_OBJ_DIR = "src-dotnet/PuduLauncher/obj/ts-manifest/generated";
const OUTPUT_DIR = "src/pudu/generated";
const JSON_CONTEXT_OUTPUT =
  "src-dotnet/PuduLauncher/Host/Serialization/JsonCtx.Models.g.cs";
const MANIFEST_FILE = "PuduContractManifest.g.cs";
const MANIFEST_START = "PUDU_MANIFEST_START";
const MANIFEST_END = "PUDU_MANIFEST_END";
const HEADER = "// This file is auto-generated by tools/generate-ts-client.js - DO NOT EDIT\n";

function toCamelCase(name) {
  return name.charAt(0).toLowerCase() + name.slice(1);
}

function toKebabCase(name) {
  return name.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}

function toPascalCase(name) {
  return name.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('');
}

function escapeTsStringLiteral(value) {
  return value.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
}

function findFilesByName(dir, fileName) {
  const matches = [];
  if (!statExists(dir)) return matches;

  for (const entry of readdirSync(dir)) {
    const full = join(dir, entry);
    const stat = statSync(full);
    if (stat.isDirectory()) {
      matches.push(...findFilesByName(full, fileName));
      continue;
    }
    if (entry === fileName) {
      matches.push(full);
    }
  }
  return matches;
}

function statExists(path) {
  try {
    statSync(path);
    return true;
  } catch {
    return false;
  }
}

function buildAndLoadManifest() {
  console.log("[generate-ts] Building .NET project to produce manifest...");
  execSync(
    `dotnet build ${DOTNET_PROJECT} -c Debug -nologo /p:EmitCompilerGeneratedFiles=true /p:CompilerGeneratedFilesOutputPath=${MANIFEST_COMPILER_GENERATED_DIR} /p:OutputPath=${MANIFEST_BUILD_OUTPUT}`,
    { stdio: "inherit" }
  );

  const manifestCandidates = findFilesByName(GENERATED_OBJ_DIR, MANIFEST_FILE).sort((a, b) => {
    const aTime = statSync(a).mtimeMs;
    const bTime = statSync(b).mtimeMs;
    return bTime - aTime;
  });

  if (manifestCandidates.length === 0) {
    throw new Error(
      `[generate-ts] Could not find ${MANIFEST_FILE} under ${GENERATED_OBJ_DIR}.`
    );
  }

  for (const file of manifestCandidates) {
    const content = readFileSync(file, "utf-8");
    const regex = new RegExp(
      `/\\*${MANIFEST_START}\\s*([\\s\\S]*?)\\s*${MANIFEST_END}\\*/`,
      "m"
    );
    const match = content.match(regex);
    if (!match) continue;

    try {
      const manifest = JSON.parse(match[1]);
      return { manifest, file };
    } catch {
    }
  }

  throw new Error(
    `[generate-ts] Could not parse manifest JSON from ${MANIFEST_FILE}.`
  );
}

function clearGeneratedFiles() {
  mkdirSync(OUTPUT_DIR, { recursive: true });

  for (const entry of readdirSync(OUTPUT_DIR)) {
    if (!entry.endsWith(".ts")) continue;
    rmSync(join(OUTPUT_DIR, entry));
  }
}

function generateTypes(manifest) {
  let output = HEADER + "\n";

  const models = [...(manifest.models ?? [])].sort((a, b) => a.name.localeCompare(b.name));
  const eventModels = models
    .filter(
      (model) =>
        typeof model.eventType === "string" &&
        model.eventType.length > 0 &&
        (model.typeParameters ?? []).length === 0
    )
    .sort((a, b) => {
      const eventTypeCompare = a.eventType.localeCompare(b.eventType);
      if (eventTypeCompare !== 0) {
        return eventTypeCompare;
      }

      return a.name.localeCompare(b.name);
    });

  for (const model of models) {
    const typeParams = model.typeParameters ?? [];
    const typeParamClause = typeParams.length > 0 ? `<${typeParams.join(", ")}>` : "";
    const extendsClause = model.baseType ? ` extends ${model.baseType}` : "";
    output += `export interface ${model.name}${typeParamClause}${extendsClause} {\n`;
    const modelEventType = typeof model.eventType === "string" ? model.eventType : null;
    const hasEventTypeProperty = (model.properties ?? []).some((prop) => prop.name === "eventType");
    if (modelEventType && !hasEventTypeProperty) {
      output += `  eventType: '${escapeTsStringLiteral(modelEventType)}';\n`;
    }
    for (const prop of model.properties ?? []) {
      const optionalMark = prop.optional ? "?" : "";
      const propType =
        modelEventType && prop.name === "eventType"
          ? `'${escapeTsStringLiteral(modelEventType)}'`
          : prop.type;
      output += `  ${prop.name}${optionalMark}: ${propType};\n`;
    }
    output += "}\n\n";
  }

  output += "export interface PuduEventMap {\n";
  for (const eventModel of eventModels) {
    output += `  '${escapeTsStringLiteral(eventModel.eventType)}': ${eventModel.name};\n`;
  }
  output += "}\n\n";
  output += "export type PuduEventType = keyof PuduEventMap;\n";
  output += "export type PuduEvent = PuduEventMap[PuduEventType];\n\n";

  return output.trimEnd() + "\n";
}

function isOpenGenericClrType(typeText, modelByName) {
  const genericMatch = typeText.match(/^(?:global::)?[\w.]+<(.+)>$/);
  if (!genericMatch) return false;

  const args = genericMatch[1]
    .split(",")
    .map((part) => part.trim())
    .map((part) => part.replace(/^global::/, ""));

  for (const arg of args) {
    if (modelByName.has(arg)) continue;
    if (/^[A-Z][A-Za-z0-9_]*$/.test(arg)) return true;
  }

  return false;
}

function normalizeClrTypeForTypeOf(typeText) {
  return typeText.replace(/\?/g, "");
}

function getCommandResultClrTypeForCommand(cmd, modelByName) {
  if (cmd.isVoid || !cmd.returnClrType) {
    return "global::PuduLauncher.Abstractions.Models.CommandResult<object>";
  }

  const normalized = normalizeClrTypeForTypeOf(cmd.returnClrType);
  if (isOpenGenericClrType(normalized, modelByName)) {
    return null;
  }

  return `global::PuduLauncher.Abstractions.Models.CommandResult<${normalized}>`;
}

function generateJsonSerializerContext(manifest) {
  const modelByName = new Set((manifest.models ?? []).map((m) => m.name));
  const clrTypes = new Set([
    "global::System.String",
    "global::PuduLauncher.Abstractions.Models.CommandResult<object>",
  ]);

  for (const model of manifest.models ?? []) {
    if (!model.clrType) continue;
    if ((model.typeParameters ?? []).length > 0) continue;
    clrTypes.add(normalizeClrTypeForTypeOf(model.clrType));
  }

  for (const controller of manifest.controllers ?? []) {
    for (const cmd of controller.commands ?? []) {
      for (const param of cmd.parameters ?? []) {
        if (param.clrType) {
          clrTypes.add(normalizeClrTypeForTypeOf(param.clrType));
        }
      }
      if (cmd.returnClrType) {
        const normalized = normalizeClrTypeForTypeOf(cmd.returnClrType);
        if (!isOpenGenericClrType(normalized, modelByName)) {
          clrTypes.add(normalized);
        }
      }

      const commandResultClrType = getCommandResultClrTypeForCommand(cmd, modelByName);
      if (commandResultClrType) {
        clrTypes.add(commandResultClrType);
      }
    }
  }

  const sortedTypes = [...clrTypes].sort();

  let output = HEADER + "\n";
  output += "using System.Text.Json.Serialization;\n\n";
  output += "namespace PuduLauncher;\n\n";
  output += "[JsonSourceGenerationOptions(\n";
  output += "    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,\n";
  output += "    PropertyNameCaseInsensitive = true,\n";
  output += "    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,\n";
  output += "    WriteIndented = false)]\n";

  for (const clrType of sortedTypes) {
    output += `[JsonSerializable(typeof(${clrType}))]\n`;
  }

  output += "public partial class JsonCtx\n";
  output += "{\n";
  output += "}\n";

  return output;
}

function extractTypeNames(type, knownTypeNames) {
  if (!type) return [];
  const matches = type.match(/\b[A-Za-z_][A-Za-z0-9_]*\b/g) ?? [];
  const refs = new Set();
  for (const token of matches) {
    if (knownTypeNames.has(token)) refs.add(token);
  }
  return [...refs];
}

function generateApiClient(controller, knownTypeNames) {
  const importTypes = new Set();
  const commands = [...(controller.commands ?? [])].sort((a, b) =>
    a.name.localeCompare(b.name)
  );

  for (const cmd of commands) {
    for (const param of cmd.parameters ?? []) {
      for (const typeName of extractTypeNames(param.type, knownTypeNames)) {
        importTypes.add(typeName);
      }
    }
    for (const typeName of extractTypeNames(cmd.returnType, knownTypeNames)) {
      importTypes.add(typeName);
    }
  }
  importTypes.add("CommandResult");

  let output = HEADER + "\n";
  if (importTypes.size > 0) {
    const importList = [...importTypes].sort().join(", ");
    output += `import type { ${importList} } from './types';\n`;
  }
  output += "import { getSidecarBaseUrl } from '../sidecar';\n\n";

  const apiClassName = toPascalCase(controller.name) + "Api";

  output += `export class ${apiClassName} {\n`;
  for (const cmd of commands) {
    const tsMethodName = toCamelCase(cmd.methodName);
    const tsInnerReturnType = cmd.isVoid ? "void" : (cmd.returnType || "unknown");
    const tsReturnType = `CommandResult<${tsInnerReturnType}>`;

    const params = cmd.parameters ?? [];

    if (params.length === 0) {
      output += `  async ${tsMethodName}(): Promise<${tsReturnType}> {\n`;
      output += "    const baseUrl = await getSidecarBaseUrl();\n";
      output += "    let response: Response;\n";
      output += "    try {\n";
      output += `      response = await fetch(\`\${baseUrl}/api/${controller.name}/${cmd.name}\`, {\n`;
      output += "        method: 'POST',\n";
      output += "      });\n";
      output += "    } catch (error) {\n";
      output += "      return { success: false, error: error instanceof Error ? error.message : 'Network request failed.' };\n";
      output += "    }\n";
    } else if (params.length === 1) {
      output += `  async ${tsMethodName}(${params[0].name}: ${params[0].type}): Promise<${tsReturnType}> {\n`;
      output += "    const baseUrl = await getSidecarBaseUrl();\n";
      output += "    let response: Response;\n";
      output += "    try {\n";
      output += `      response = await fetch(\`\${baseUrl}/api/${controller.name}/${cmd.name}\`, {\n`;
      output += "        method: 'POST',\n";
      output += "        headers: { 'Content-Type': 'application/json' },\n";
      output += `        body: JSON.stringify(${params[0].name}),\n`;
      output += "      });\n";
      output += "    } catch (error) {\n";
      output += "      return { success: false, error: error instanceof Error ? error.message : 'Network request failed.' };\n";
      output += "    }\n";
    } else {
      const paramSig = params.map(p => `${p.name}: ${p.type}`).join("; ");
      output += `  async ${tsMethodName}(params: { ${paramSig} }): Promise<${tsReturnType}> {\n`;
      output += "    const baseUrl = await getSidecarBaseUrl();\n";
      output += "    let response: Response;\n";
      output += "    try {\n";
      output += `      response = await fetch(\`\${baseUrl}/api/${controller.name}/${cmd.name}\`, {\n`;
      output += "        method: 'POST',\n";
      output += "        headers: { 'Content-Type': 'application/json' },\n";
      output += "        body: JSON.stringify(params),\n";
      output += "      });\n";
      output += "    } catch (error) {\n";
      output += "      return { success: false, error: error instanceof Error ? error.message : 'Network request failed.' };\n";
      output += "    }\n";
    }

    output += "    if (!response.ok) {\n";
    output += "      return { success: false, error: `HTTP error! status: ${response.status}` };\n";
    output += "    }\n";
    output += "    try {\n";
    output += `      return await response.json() as ${tsReturnType};\n`;
    output += "    } catch {\n";
    output += "      return { success: false, error: 'Invalid JSON response from server.' };\n";
    output += "    }\n";
    output += "  }\n\n";
  }

  output = output.trimEnd() + "\n}\n";
  return {
    fileName: `${toKebabCase(controller.name)}-api.ts`,
    content: output,
    apiClassName,
  };
}

function generatePreferencesSchema(manifest) {
  const models = manifest.models ?? [];

  const categoryModels = new Map();
  for (const model of models) {
    if (typeof model.categoryLabel === "string" && model.categoryLabel.length > 0) {
      categoryModels.set(model.name, model);
    }
  }

  if (categoryModels.size === 0) return null;

  const preferencesModel = models.find((m) => m.name === "Preferences");
  if (!preferencesModel) return null;

  const categories = [];
  for (const prop of preferencesModel.properties ?? []) {
    const categoryModel = categoryModels.get(prop.type);
    if (!categoryModel) continue;

    const fields = [];
    for (const field of categoryModel.properties ?? []) {
      if (typeof field.label === "string" && typeof field.component === "string") {
        const entry = { key: field.name, label: field.label, component: field.component };
        if (typeof field.tooltip === "string" && field.tooltip.length > 0) {
          entry.tooltip = field.tooltip;
        }
        if (Array.isArray(field.options) && field.options.length > 0) {
          entry.options = field.options
            .filter((option) => typeof option === "string")
            .map((option) => option.trim())
            .filter((option) => option.length > 0);
          if (entry.options.length === 0) {
            delete entry.options;
          }
        }
        fields.push(entry);
      }
    }

    categories.push({
      key: prop.name,
      label: categoryModel.categoryLabel,
      layout: categoryModel.categoryLayout ?? null,
      fields,
    });
  }

  if (categories.length === 0) return null;

  const componentValues = new Set();
  for (const cat of categories) {
    for (const field of cat.fields) {
      componentValues.add(field.component);
    }
  }
  const sortedComponents = [...componentValues].sort();

  const layoutValues = new Set();
  for (const cat of categories) {
    if (typeof cat.layout === "string" && cat.layout.length > 0) {
      layoutValues.add(cat.layout);
    }
  }
  const sortedLayouts = [...layoutValues].sort();

  let output = HEADER + "\n";
  output += `export type PreferenceComponent = ${sortedComponents.map((c) => `'${escapeTsStringLiteral(c)}'`).join(" | ")};\n\n`;
  if (sortedLayouts.length > 0) {
    output += `export type CategoryLayout = ${sortedLayouts.map((l) => `'${escapeTsStringLiteral(l)}'`).join(" | ")};\n\n`;
  }
  output += "export interface PreferenceFieldSchema {\n";
  output += "  key: string;\n";
  output += "  label: string;\n";
  output += "  component: PreferenceComponent;\n";
  output += "  tooltip?: string;\n";
  output += "  options?: string[];\n";
  output += "}\n\n";
  output += "export interface PreferenceCategorySchema {\n";
  output += "  key: string;\n";
  output += "  label: string;\n";
  if (sortedLayouts.length > 0) {
    output += "  layout?: CategoryLayout;\n";
  }
  output += "  fields: PreferenceFieldSchema[];\n";
  output += "}\n\n";
  output += "export const preferencesSchema: PreferenceCategorySchema[] = [\n";

  for (const cat of categories) {
    output += "  {\n";
    output += `    key: '${escapeTsStringLiteral(cat.key)}',\n`;
    output += `    label: '${escapeTsStringLiteral(cat.label)}',\n`;
    if (typeof cat.layout === "string" && cat.layout.length > 0) {
      output += `    layout: '${escapeTsStringLiteral(cat.layout)}',\n`;
    }
    output += "    fields: [\n";
    for (const field of cat.fields) {
      output += "      { ";
      output += `key: '${escapeTsStringLiteral(field.key)}', `;
      output += `label: '${escapeTsStringLiteral(field.label)}', `;
      output += `component: '${escapeTsStringLiteral(field.component)}'`;
      if (typeof field.tooltip === "string" && field.tooltip.length > 0) {
        output += `, tooltip: '${escapeTsStringLiteral(field.tooltip)}'`;
      }
      if (Array.isArray(field.options) && field.options.length > 0) {
        output += `, options: [${field.options.map((option) => `'${escapeTsStringLiteral(option)}'`).join(", ")}]`;
      }
      output += " },\n";
    }
    output += "    ],\n";
    output += "  },\n";
  }

  output += "];\n";
  return output;
}

function generateIndex(apiFiles, hasPreferencesSchema) {
  let output = HEADER + "\n";
  output += "export * from './types';\n";
  if (hasPreferencesSchema) {
    output += "export * from './preferences-schema';\n";
  }
  for (const { fileName, apiClassName } of apiFiles) {
    const moduleName = "./" + fileName.replace(".ts", "");
    output += `export { ${apiClassName} } from '${moduleName}';\n`;
  }
  return output;
}

function main() {
  const { manifest, file } = buildAndLoadManifest();
  const controllers = [...(manifest.controllers ?? [])].sort((a, b) =>
    a.name.localeCompare(b.name)
  );

  console.log(
    `[generate-ts] Loaded manifest v${manifest.version} from ${file} (${controllers.length} controller(s), ${(manifest.models ?? []).length} model(s))`
  );

  clearGeneratedFiles();

  const typesContent = generateTypes(manifest);
  writeFileSync(join(OUTPUT_DIR, "types.ts"), typesContent);
  console.log("[generate-ts] Generated types.ts");

  const jsonContextContent = generateJsonSerializerContext(manifest);
  mkdirSync(dirname(JSON_CONTEXT_OUTPUT), { recursive: true });
  writeFileSync(JSON_CONTEXT_OUTPUT, jsonContextContent);
  console.log("[generate-ts] Generated JsonCtx.Models.g.cs");

  const knownTypeNames = new Set([
    ...((manifest.models ?? []).map((m) => m.name)),
  ]);

  const preferencesSchemaContent = generatePreferencesSchema(manifest);
  const hasPreferencesSchema = preferencesSchemaContent !== null;
  if (hasPreferencesSchema) {
    writeFileSync(join(OUTPUT_DIR, "preferences-schema.ts"), preferencesSchemaContent);
    console.log("[generate-ts] Generated preferences-schema.ts");
  }

  const apiFiles = [];
  for (const controller of controllers) {
    const { fileName, content, apiClassName } = generateApiClient(
      controller,
      knownTypeNames
    );
    writeFileSync(join(OUTPUT_DIR, fileName), content);
    apiFiles.push({ fileName, apiClassName });
    console.log(`[generate-ts] Generated ${fileName}`);
  }

  const indexContent = generateIndex(apiFiles, hasPreferencesSchema);
  writeFileSync(join(OUTPUT_DIR, "index.ts"), indexContent);
  console.log("[generate-ts] Generated index.ts");

  console.log(`[generate-ts] Done! Output: ${OUTPUT_DIR}/`);
}

main();
